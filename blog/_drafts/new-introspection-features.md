---
layout: main/blog-post
title: Introspecting Pallet (part I)
author: Antoni Batchelli
section: blog
summary: Pallet 0.8.0-beta.11, along with pallet-repl 0.8.0-beta.2
         provide a set of functions to introspect Pallet actions,
         either before executing them by asking Pallet what it is
         going to do, and after executing by asking Pallet what it did
         and how it went.
---

NOTES: Voices: Pallet, developer, will

Pallet 0.8.0-beta.11, in conjunction with pallet-repl 0.8.0-beta.2,
gained two new features that will improve user's experience. These
features provide instant feedback on what pallet is going to do for a
phase or plan function, or what pallet did during a run. 

## explain-plan and explain-phase

These two functions in `pallet.repl` will execute pallet's planner and
print out the actions it plans to run, along with the corresponding
scripts for such actions. This feature lets users have instant
feedback on what pallet will do provided a plan function or a phase in
a spec.

## Explaining a Plan

When writing a plan function, it is convenient to understand what
Pallet will execute when running such function.
`pallet.repl/explain-plan` does just this. Let's see a few examples:

```clojure
user=> (explain-plan (plan-fn (exec-script (println "hello world!"))))
```

will result in:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/exec-script* of type script executed on target
  FORM:
    (pallet.actions/exec-script* "echo hello world!")
  SCRIPT:
    | echo hello world!
```

What this is telling us is that Pallet ran a mock run with an Ubuntu
v12.04 node (the default), and that for this plan function, it ran a
single action (`exec-script`) that once compiled for Ubuntu 12.04, it
resulted in running `echo hello world!` at the shell.

### Options for `explain-plan`

You pass options to `explain-plan` to control the information that
will be printed out. For example, with `:print-forms false`, the
output will only contain the `SCRIPT` portion of each action, e.g:

```clojure
user=> (explain-plan (plan-fn (exec-script (println "hello world!" )))
 :print-forms false)
```

results in:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/exec-script* of type script executed on target
  SCRIPT:
    | echo hello world!
```

whereas using `:print-scripts false` will result in the action forms
being printed, but not the scripts:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/exec-script* of type script executed on target
  FORM:
    (pallet.actions/exec-script* "echo hello world!")
```

### Testing Different OSs

You can inspect the actions and the scripts generated by Pallet on
different OSs too. For example, creating a user that belongs to a few
different groups is done differently for Ubuntu and CentOS. Let's see
how. This is the plan to create a user named `user` that belongs to
two groups named `group-a` and `group-b`:

```clojure
(def my-plan 
   (plan-fn (user "test-user" :groups ["group-a" "group-b"])))
```

In Ubuntu:

```clojure
user=> (explain-plan my-plan :print-forms false)
```

results in:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/user of type script executed on target
  SCRIPT:
    | if
    | getent passwd test-user; then
    | /usr/sbin/usermod --groups "group-a,group-b" test-user
    | else
    | /usr/sbin/useradd --groups "group-a,group-b" test-user
    | fi
```

whereas for CentOS:

```clojure
(explain-plan my-plan :print-forms false :os-family :centos :os-version "6")
```
results in:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :centos :os-version "6"]
ACTION: pallet.actions/user of type script executed on target
  SCRIPT:
    | if
    | getent passwd test-user; then
    | /usr/sbin/usermod -G "group-a,group-b" test-user
    | else
    | /usr/sbin/useradd -G "group-a,group-b" test-user
    | fi
```

Notice that the differences, in this case, are subtle: in both cases
Pallet will use `usermod` if the user already exists and `useradd` if
it doesn't, but for Ubuntu, the switch to assign the user to the
groups is `--groups` and for CentOS, it's `-G` instead.

### Plans That Use Settings

If the plan function you are inspecting uses contents in, you can pass
a settings phase to `explain-plan` with the key `:settings-phase` that
will be run before running your phase and thus make the settings
available to the actions in your plan. In the following exmaple, we'll
have a plan function that will take a name from the settings (under
the facility `:my-service`) and print it on the node:

```clojure
(def my-plan
  (api/plan-fn []
               (let [name (:name (crate/get-settings :my-service))]
                 (actions/exec-script
                  (println ~name)))))
```

Let's give it a test. We'll run `explain-plan` with a settings phase
that sets the value for `:name` in the facility `:my-service`:

```clojure                
user=> (explain-plan my-plan 
          :settings-phase 
          (api/plan-fn
           (crate/assoc-settings :my-service {:name "Bob})))
```

and this yields:

```
NODE: ["mock-node" "mock-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/exec-script* of type script executed on target
  FORM:
    (pallet.actions/exec-script* "echo Bob")
  SCRIPT:
    | echo Bob
```

As you can see, now the action's us using the contents of the
settings.

## Explaining a Phase

If you want to inspect a phase in a server or group spec, you can do
so with `explain-phase`. This function works the same as
`explain-plan` but will take a `server-spec` and a phase instead of a
plan function. For example, for installing Java, we create a
group-expect that extends the Java server spec found in the the Java
crate:

```clojure
(def my-group (group-spec "my-group" :extends [(java/server-spec {})]))
```

We call `explain-phase` in a similar way we would call `explain-plan`,
but this time we pass the group and the phase in the group to explain:

```clojure
user=> (explain-phase my-group :phase :install :print-forms false)
```

which results in: 

```
NODE: ["mock-node" "my-group" "0.0.0.0" :ubuntu :os-version "12.04"]
ACTION: pallet.actions/package of type script executed on target
  SCRIPT:
    | echo '[install: install]: Packages...';
    | {
    | apt-get -q -y install openjdk-7-jdk+ && \
    | dpkg --get-selections
    |  } || { echo '#> [install: install]: Packages : FAIL'; exit 1;} >&2 
    | echo '#> [install: install]: Packages : SUCCESS'
WHEN true :
  ACTION: pallet.actions/exec-script* of type script executed on target
    SCRIPT:
      | echo 'Add java environment to /etc/environment...';
      | {
      | if ! ( [ -e /etc/environment ] ); then
      | { cat > /etc/environment <<EOFpallet
      | # environment file created by pallet
      | 
      | EOFpallet
      |  }
      | fi
      | pallet_set_env() {
      | k=$1
      | v=$2
      | s=$3
      | if ! ( grep "${s}" /etc/environment 2>&- ); then
      | sed -i -e "/$${k}=/ d" /etc/environment && sed -i -e "$ a \\
      | ${s}" /etc/environment || exit 1
      | fi
      | } && vv="$(dirname $(dirname $(update-alternatives --query javac | grep Best: | cut -f 2 -d ' ')))"
      | pallet_set_env "JAVA_HOME" "${vv}" "JAVA_HOME=\"${vv}\""
      |  } || { echo '#> Add java environment to /etc/environment : FAIL'; exit 1;} >&2 
      | echo '#> Add java environment to /etc/environment : SUCCESS'

```
